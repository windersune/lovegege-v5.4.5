var et = Object.defineProperty;
var tt = (e, t, s) => t in e ? et(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s;
var u = (e, t, s) => (tt(e, typeof t != "symbol" ? t + "" : t, s), s), $e = (e, t, s) => {
  if (!t.has(e))
    throw TypeError("Cannot " + s);
};
var V = (e, t, s) => ($e(e, t, "read from private field"), s ? s.call(e) : t.get(e)), ke = (e, t, s) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, s);
}, Re = (e, t, s, n) => ($e(e, t, "write to private field"), n ? n.call(e, s) : t.set(e, s), s);
var fe = new Intl.Collator(0, { numeric: 1 }).compare;
function Pe(e, t, s) {
  return e = e.split("."), t = t.split("."), fe(e[0], t[0]) || fe(e[1], t[1]) || (t[2] = t.slice(2).join("."), s = /[.-]/.test(e[2] = e.slice(2).join(".")), s == /[.-]/.test(t[2]) ? fe(e[2], t[2]) : s ? -1 : 1);
}
const st = "host", je = "queue/data", nt = "queue/join", Oe = "upload", it = "login", Ne = "config", ot = "info", rt = "runtime", at = "sleeptime", ct = "heartbeat", lt = "component_server", ut = "reset", pt = "cancel", ft = "app_id", ht = "https://gradio-space-api-fetcher-v2.hf.space/api", xe = "This application is currently busy. Please try again. ", J = "Connection errored out. ", z = "Could not resolve app config. ", dt = "Could not get space status. ", _t = "Could not get API info. ", me = "Space metadata could not be loaded. ", mt = "Invalid URL. A full URL path is required.", gt = "Not authorized to access this space. ", Ie = "Invalid credentials. Could not login. ", wt = "Login credentials are required to access this space.", yt = "File system access is only available in Node.js environments", Ue = "Root URL not found in client config", bt = "Error uploading file";
function vt(e, t, s) {
  return t.startsWith("http://") || t.startsWith("https://") ? s ? e : t : e + t;
}
async function Te(e, t, s) {
  try {
    return (await (await fetch(`https://huggingface.co/api/spaces/${e}/jwt`, {
      headers: {
        Authorization: `Bearer ${t}`,
        ...s ? { Cookie: s } : {}
      }
    })).json()).token || !1;
  } catch {
    return !1;
  }
}
function Et(e) {
  let t = {};
  return e.forEach(({ api_name: s, id: n }) => {
    s && (t[s] = n);
  }), t;
}
async function St(e) {
  const t = this.options.hf_token ? { Authorization: `Bearer ${this.options.hf_token}` } : {};
  if (t["Content-Type"] = "application/json", typeof window < "u" && window.gradio_config && location.origin !== "http://localhost:9876" && !window.gradio_config.dev_mode)
    return window.gradio_config.current_page && (e = e.substring(0, e.lastIndexOf("/"))), window.gradio_config.root = e, { ...window.gradio_config };
  if (e) {
    let s = Be(
      e,
      this.deep_link ? Ne + "?deep_link=" + this.deep_link : Ne
    );
    const n = await this.fetch(s, {
      headers: t,
      credentials: "include"
    });
    return $t(n, e, !!this.options.auth);
  }
  throw new Error(z);
}
async function $t(e, t, s) {
  var n, i;
  if ((e == null ? void 0 : e.status) === 401 && !s) {
    const r = await e.json(), o = (n = r == null ? void 0 : r.detail) == null ? void 0 : n.auth_message;
    throw new Error(o || wt);
  } else if ((e == null ? void 0 : e.status) === 401 && s)
    throw new Error(Ie);
  if ((e == null ? void 0 : e.status) === 200) {
    let r = await e.json();
    return r.root = t, (i = r.dependencies) == null || i.forEach((o, a) => {
      o.id === void 0 && (o.id = a);
    }), r;
  } else if ((e == null ? void 0 : e.status) === 401)
    throw new Error(gt);
  throw new Error(z);
}
async function kt() {
  const { http_protocol: e, host: t } = await te(
    this.app_reference,
    this.options.hf_token
  );
  try {
    if (this.options.auth) {
      const s = await qe(
        e,
        t,
        this.options.auth,
        this.fetch,
        this.options.hf_token
      );
      s && this.set_cookies(s);
    }
  } catch (s) {
    throw Error(s.message);
  }
}
async function qe(e, t, s, n, i) {
  const r = new FormData();
  r.append("username", s == null ? void 0 : s[0]), r.append("password", s == null ? void 0 : s[1]);
  let o = {};
  i && (o.Authorization = `Bearer ${i}`);
  const a = await n(`${e}//${t}/${it}`, {
    headers: o,
    method: "POST",
    body: r,
    credentials: "include"
  });
  if (a.status === 200)
    return a.headers.get("set-cookie");
  throw a.status === 401 ? new Error(Ie) : new Error(me);
}
function he(e) {
  if (e.startsWith("http")) {
    const { protocol: t, host: s, pathname: n } = new URL(e);
    return {
      ws_protocol: t === "https:" ? "wss" : "ws",
      http_protocol: t,
      host: s + (n !== "/" ? n : "")
    };
  } else if (e.startsWith("file:"))
    return {
      ws_protocol: "ws",
      http_protocol: "http:",
      host: "lite.local"
      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.
    };
  return {
    ws_protocol: "wss",
    http_protocol: "https:",
    host: new URL(e).host
  };
}
const ze = (e) => {
  let t = [];
  return e.split(/,(?=\s*[^\s=;]+=[^\s=;]+)/).forEach((n) => {
    const [i, r] = n.split(";")[0].split("=");
    i && r && t.push(`${i.trim()}=${r.trim()}`);
  }), t;
}, ge = /^[a-zA-Z0-9_\-\.]+\/[a-zA-Z0-9_\-\.]+$/, Rt = /.*hf\.space\/{0,1}.*$/;
async function te(e, t) {
  const s = {};
  t && (s.Authorization = `Bearer ${t}`);
  const n = e.trim().replace(/\/$/, "");
  if (ge.test(n))
    try {
      const r = (await (await fetch(
        `https://huggingface.co/api/spaces/${n}/${st}`,
        { headers: s }
      )).json()).host;
      return {
        space_id: e,
        ...he(r)
      };
    } catch {
      throw new Error(me);
    }
  if (Rt.test(n)) {
    const { ws_protocol: i, http_protocol: r, host: o } = he(n);
    return {
      space_id: o.split("/")[0].replace(".hf.space", ""),
      ws_protocol: i,
      http_protocol: r,
      host: o
    };
  }
  return {
    space_id: !1,
    ...he(n)
  };
}
const Be = (...e) => {
  try {
    return e.reduce((t, s) => (t = t.replace(/\/+$/, ""), s = s.replace(/^\/+/, ""), new URL(s, t + "/").toString()));
  } catch {
    throw new Error(mt);
  }
};
function Ot(e, t, s) {
  const n = {
    named_endpoints: {},
    unnamed_endpoints: {}
  };
  return Object.keys(e).forEach((i) => {
    (i === "named_endpoints" || i === "unnamed_endpoints") && (n[i] = {}, Object.entries(e[i]).forEach(
      ([r, { parameters: o, returns: a }]) => {
        var p, g, E, B;
        const l = ((p = t.dependencies.find(
          (c) => c.api_name === r || c.api_name === r.replace("/", "")
        )) == null ? void 0 : p.id) || s[r.replace("/", "")] || -1, h = l !== -1 ? (g = t.dependencies.find((c) => c.id == l)) == null ? void 0 : g.types : { generator: !1, cancel: !1 };
        if (l !== -1 && ((B = (E = t.dependencies.find((c) => c.id == l)) == null ? void 0 : E.inputs) == null ? void 0 : B.length) !== o.length) {
          const c = t.dependencies.find((_) => _.id == l).inputs.map(
            (_) => {
              var N;
              return (N = t.components.find((C) => C.id === _)) == null ? void 0 : N.type;
            }
          );
          try {
            c.forEach((_, N) => {
              if (_ === "state") {
                const C = {
                  component: "state",
                  example: null,
                  parameter_default: null,
                  parameter_has_default: !0,
                  parameter_name: null,
                  hidden: !0
                };
                o.splice(N, 0, C);
              }
            });
          } catch (_) {
            console.error(_);
          }
        }
        const m = (c, _, N, C) => ({
          ...c,
          description: Tt(c == null ? void 0 : c.type, N),
          type: Nt(c == null ? void 0 : c.type, _, N, C) || ""
        });
        n[i][r] = {
          parameters: o.map(
            (c) => m(c, c == null ? void 0 : c.component, c == null ? void 0 : c.serializer, "parameter")
          ),
          returns: a.map(
            (c) => m(c, c == null ? void 0 : c.component, c == null ? void 0 : c.serializer, "return")
          ),
          type: h
        };
      }
    ));
  }), n;
}
function Nt(e, t, s, n) {
  if (t === "Api")
    return e.type;
  switch (e == null ? void 0 : e.type) {
    case "string":
      return "string";
    case "boolean":
      return "boolean";
    case "number":
      return "number";
  }
  if (s === "JSONSerializable" || s === "StringSerializable")
    return "any";
  if (s === "ListStringSerializable")
    return "string[]";
  if (t === "Image")
    return n === "parameter" ? "Blob | File | Buffer" : "string";
  if (s === "FileSerializable")
    return (e == null ? void 0 : e.type) === "array" ? n === "parameter" ? "(Blob | File | Buffer)[]" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]" : n === "parameter" ? "Blob | File | Buffer" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}";
  if (s === "GallerySerializable")
    return n === "parameter" ? "[(Blob | File | Buffer), (string | null)][]" : "[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]";
}
function Tt(e, t) {
  return t === "GallerySerializable" ? "array of [file, label] tuples" : t === "ListStringSerializable" ? "array of strings" : t === "FileSerializable" ? "array of files or single file" : e == null ? void 0 : e.description;
}
function de(e, t) {
  switch (e.msg) {
    case "send_data":
      return { type: "data" };
    case "send_hash":
      return { type: "hash" };
    case "queue_full":
      return {
        type: "update",
        status: {
          queue: !0,
          message: xe,
          stage: "error",
          code: e.code,
          success: e.success
        }
      };
    case "heartbeat":
      return {
        type: "heartbeat"
      };
    case "unexpected_error":
      return {
        type: "unexpected_error",
        status: {
          queue: !0,
          message: e.message,
          session_not_found: e.session_not_found,
          stage: "error",
          success: !1
        }
      };
    case "broken_connection":
      return {
        type: "broken_connection",
        status: {
          queue: !0,
          message: e.message,
          stage: "error",
          success: !1
        }
      };
    case "estimation":
      return {
        type: "update",
        status: {
          queue: !0,
          stage: t || "pending",
          code: e.code,
          size: e.queue_size,
          position: e.rank,
          eta: e.rank_eta,
          success: e.success
        }
      };
    case "progress":
      return {
        type: "update",
        status: {
          queue: !0,
          stage: "pending",
          code: e.code,
          progress_data: e.progress_data,
          success: e.success
        }
      };
    case "log":
      return { type: "log", data: e };
    case "process_generating":
      return {
        type: "generating",
        status: {
          queue: !0,
          message: e.success ? null : e.output.error,
          stage: e.success ? "generating" : "error",
          code: e.code,
          progress_data: e.progress_data,
          eta: e.average_duration,
          changed_state_ids: e.success ? e.output.changed_state_ids : void 0
        },
        data: e.success ? e.output : null
      };
    case "process_streaming":
      return {
        type: "streaming",
        status: {
          queue: !0,
          message: e.output.error,
          stage: "streaming",
          time_limit: e.time_limit,
          code: e.code,
          progress_data: e.progress_data,
          eta: e.eta
        },
        data: e.output
      };
    case "process_completed":
      return "error" in e.output ? {
        type: "update",
        status: {
          queue: !0,
          title: e.output.title,
          message: e.output.error,
          visible: e.output.visible,
          duration: e.output.duration,
          stage: "error",
          code: e.code,
          success: e.success
        }
      } : {
        type: "complete",
        status: {
          queue: !0,
          message: e.success ? void 0 : e.output.error,
          stage: e.success ? "complete" : "error",
          code: e.code,
          progress_data: e.progress_data,
          changed_state_ids: e.success ? e.output.changed_state_ids : void 0
        },
        data: e.success ? e.output : null
      };
    case "process_starts":
      return {
        type: "update",
        status: {
          queue: !0,
          stage: "pending",
          code: e.code,
          size: e.rank,
          position: 0,
          success: e.success,
          eta: e.eta
        },
        original_msg: "process_starts"
      };
  }
  return { type: "none", status: { stage: "error", queue: !0 } };
}
const Dt = (e = [], t) => {
  const s = t ? t.parameters : [];
  if (Array.isArray(e))
    return t && s.length > 0 && e.length > s.length && console.warn("Too many arguments provided for the endpoint."), e;
  const n = [], i = Object.keys(e);
  return s.forEach((r, o) => {
    if (e.hasOwnProperty(r.parameter_name))
      n[o] = e[r.parameter_name];
    else if (r.parameter_has_default)
      n[o] = r.parameter_default;
    else
      throw new Error(
        `No value provided for required parameter: ${r.parameter_name}`
      );
  }), i.forEach((r) => {
    if (!s.some((o) => o.parameter_name === r))
      throw new Error(
        `Parameter \`${r}\` is not a valid keyword argument. Please refer to the API for usage.`
      );
  }), n.forEach((r, o) => {
    if (r === void 0 && !s[o].parameter_has_default)
      throw new Error(
        `No value provided for required parameter: ${s[o].parameter_name}`
      );
  }), n;
};
async function Ct() {
  if (this.api_info)
    return this.api_info;
  const { hf_token: e } = this.options, { config: t } = this, s = { "Content-Type": "application/json" };
  if (e && (s.Authorization = `Bearer ${e}`), !!t)
    try {
      let n, i;
      if (typeof window < "u" && window.gradio_api_info)
        i = window.gradio_api_info;
      else {
        if (Pe((t == null ? void 0 : t.version) || "2.0.0", "3.30") < 0)
          n = await this.fetch(ht, {
            method: "POST",
            body: JSON.stringify({
              serialize: !1,
              config: JSON.stringify(t)
            }),
            headers: s,
            credentials: "include"
          });
        else {
          const r = Be(t.root, this.api_prefix, ot);
          n = await this.fetch(r, {
            headers: s,
            credentials: "include"
          });
        }
        if (!n.ok)
          throw new Error(J);
        i = await n.json();
      }
      return "api" in i && (i = i.api), i.named_endpoints["/predict"] && !i.unnamed_endpoints[0] && (i.unnamed_endpoints[0] = i.named_endpoints["/predict"]), Ot(i, t, this.api_map);
    } catch (n) {
      throw new Error("Could not get API info. " + n.message);
    }
}
async function At(e, t, s) {
  var a;
  const n = {};
  (a = this == null ? void 0 : this.options) != null && a.hf_token && (n.Authorization = `Bearer ${this.options.hf_token}`);
  const i = 1e3, r = [];
  let o;
  for (let l = 0; l < t.length; l += i) {
    const h = t.slice(l, l + i), m = new FormData();
    h.forEach((g) => {
      m.append("files", g);
    });
    try {
      const g = s ? `${e}${this.api_prefix}/${Oe}?upload_id=${s}` : `${e}${this.api_prefix}/${Oe}`;
      o = await this.fetch(g, {
        method: "POST",
        body: m,
        headers: n,
        credentials: "include"
      });
    } catch (g) {
      throw new Error(J + g.message);
    }
    if (!o.ok) {
      const g = await o.text();
      return { error: `HTTP ${o.status}: ${g}` };
    }
    const p = await o.json();
    p && r.push(...p);
  }
  return { files: r };
}
async function Lt(e, t, s, n) {
  let i = (Array.isArray(e) ? e : [e]).map(
    (o) => o.blob
  );
  const r = i.filter(
    (o) => o.size > (n ?? 1 / 0)
  );
  if (r.length)
    throw new Error(
      `File size exceeds the maximum allowed size of ${n} bytes: ${r.map((o) => o.name).join(", ")}`
    );
  return await Promise.all(
    await this.upload_files(t, i, s).then(
      async (o) => {
        if (o.error)
          throw new Error(o.error);
        return o.files ? o.files.map((a, l) => new se({
          ...e[l],
          path: a,
          url: `${t}${this.api_prefix}/file=${a}`
        })) : [];
      }
    )
  );
}
async function as(e, t) {
  return e.map(
    (s) => new se({
      path: s.name,
      orig_name: s.name,
      blob: s,
      size: s.size,
      mime_type: s.type,
      is_stream: t
    })
  );
}
class se {
  constructor({
    path: t,
    url: s,
    orig_name: n,
    size: i,
    blob: r,
    is_stream: o,
    mime_type: a,
    alt_text: l,
    b64: h
  }) {
    u(this, "path");
    u(this, "url");
    u(this, "orig_name");
    u(this, "size");
    u(this, "blob");
    u(this, "is_stream");
    u(this, "mime_type");
    u(this, "alt_text");
    u(this, "b64");
    u(this, "meta", { _type: "gradio.FileData" });
    this.path = t, this.url = s, this.orig_name = n, this.size = i, this.blob = s ? void 0 : r, this.is_stream = o, this.mime_type = a, this.alt_text = l, this.b64 = h;
  }
}
class Fe {
  constructor(t, s) {
    u(this, "type");
    u(this, "command");
    u(this, "meta");
    u(this, "fileData");
    this.type = "command", this.command = t, this.meta = s;
  }
}
const Pt = typeof process < "u" && process.versions && process.versions.node;
function De(e, t, s) {
  for (; s.length > 1; ) {
    const i = s.shift();
    if (typeof i == "string" || typeof i == "number")
      e = e[i];
    else
      throw new Error("Invalid key type");
  }
  const n = s.shift();
  if (typeof n == "string" || typeof n == "number")
    e[n] = t;
  else
    throw new Error("Invalid key type");
}
async function _e(e, t = void 0, s = [], n = !1, i = void 0) {
  if (Array.isArray(e)) {
    let r = [];
    return await Promise.all(
      e.map(async (o, a) => {
        var m;
        let l = s.slice();
        l.push(String(a));
        const h = await _e(
          e[a],
          n ? ((m = i == null ? void 0 : i.parameters[a]) == null ? void 0 : m.component) || void 0 : t,
          l,
          !1,
          i
        );
        r = r.concat(h);
      })
    ), r;
  } else {
    if (globalThis.Buffer && e instanceof globalThis.Buffer || e instanceof Blob)
      return [
        {
          path: s,
          blob: new Blob([e]),
          type: t
        }
      ];
    if (typeof e == "object" && e !== null) {
      let r = [];
      for (const o of Object.keys(e)) {
        const a = [...s, o], l = e[o];
        r = r.concat(
          await _e(
            l,
            void 0,
            a,
            !1,
            i
          )
        );
      }
      return r;
    }
  }
  return [];
}
function jt(e, t) {
  var n, i;
  let s = (i = (n = t == null ? void 0 : t.dependencies) == null ? void 0 : n.find((r) => r.id == e)) == null ? void 0 : i.queue;
  return s != null ? !s : !t.enable_queue;
}
function xt(e, t) {
  return new Promise((s, n) => {
    const i = new MessageChannel();
    i.port1.onmessage = ({ data: r }) => {
      i.port1.close(), s(r);
    }, window.parent.postMessage(e, t, [i.port2]);
  });
}
function cs(e) {
  if (typeof e == "string") {
    if (e.startsWith("http://") || e.startsWith("https://"))
      return {
        path: e,
        url: e,
        orig_name: e.split("/").pop() ?? "unknown",
        meta: { _type: "gradio.FileData" }
      };
    if (Pt)
      return new Fe("upload_file", {
        path: e,
        name: e,
        orig_path: e
      });
  } else {
    if (typeof File < "u" && e instanceof File)
      return new Blob([e]);
    if (e instanceof Buffer)
      return new Blob([e]);
    if (e instanceof Blob)
      return e;
  }
  throw new Error(
    "Invalid input: must be a URL, File, Blob, or Buffer object."
  );
}
function X(e, t, s, n, i = !1) {
  if (n === "input" && !i)
    throw new Error("Invalid code path. Cannot skip state inputs for input.");
  if (n === "output" && i)
    return e;
  let r = [], o = 0;
  const a = n === "input" ? t.inputs : t.outputs;
  for (let l = 0; l < a.length; l++) {
    const h = a[l], m = s.find((p) => p.id === h);
    if ((m == null ? void 0 : m.type) === "state") {
      if (i)
        if (e.length === a.length) {
          const p = e[o];
          r.push(p), o++;
        } else
          r.push(null);
      else {
        o++;
        continue;
      }
      continue;
    } else {
      const p = e[o];
      r.push(p), o++;
    }
  }
  return r;
}
async function It(e, t, s) {
  const n = this;
  await Ut(n, t);
  const i = await _e(
    t,
    void 0,
    [],
    !0,
    s
  );
  return (await Promise.all(
    i.map(async ({ path: o, blob: a, type: l }) => {
      if (!a)
        return { path: o, type: l };
      const h = await n.upload_files(e, [a]), m = h.files && h.files[0];
      return {
        path: o,
        file_url: m,
        type: l,
        name: typeof File < "u" && a instanceof File ? a == null ? void 0 : a.name : void 0
      };
    })
  )).forEach(({ path: o, file_url: a, type: l, name: h }) => {
    if (l === "Gallery")
      De(t, a, o);
    else if (a) {
      const m = new se({ path: a, orig_name: h });
      De(t, m, o);
    }
  }), t;
}
async function Ut(e, t) {
  var n, i;
  if (!(((n = e.config) == null ? void 0 : n.root) || ((i = e.config) == null ? void 0 : i.root_url)))
    throw new Error(Ue);
  await Ge(e, t);
}
async function Ge(e, t, s = []) {
  for (const n in t)
    t[n] instanceof Fe ? await qt(e, t, n) : typeof t[n] == "object" && t[n] !== null && await Ge(e, t[n], [...s, n]);
}
async function qt(e, t, s) {
  var r, o;
  let n = t[s];
  const i = ((r = e.config) == null ? void 0 : r.root) || ((o = e.config) == null ? void 0 : o.root_url);
  if (!i)
    throw new Error(Ue);
  try {
    let a, l;
    if (typeof process < "u" && process.versions && process.versions.node) {
      const g = await import("./__vite-browser-external-DYxpcVy9.js");
      l = (await import("./__vite-browser-external-DYxpcVy9.js")).resolve(process.cwd(), n.meta.path), a = await g.readFile(l);
    } else
      throw new Error(yt);
    const h = new Blob([a], { type: "application/octet-stream" }), m = await e.upload_files(i, [h]), p = m.files && m.files[0];
    if (p) {
      const g = new se({
        path: p,
        orig_name: n.meta.name || ""
      });
      t[s] = g;
    }
  } catch (a) {
    console.error(bt, a);
  }
}
async function zt(e, t, s) {
  const n = { "Content-Type": "application/json" };
  this.options.hf_token && (n.Authorization = `Bearer ${this.options.hf_token}`);
  try {
    var i = await this.fetch(e, {
      method: "POST",
      body: JSON.stringify(t),
      headers: { ...n, ...s },
      credentials: "include"
    });
  } catch {
    return [{ error: J }, 500];
  }
  let r, o;
  try {
    r = await i.json(), o = i.status;
  } catch (a) {
    r = { error: `Could not parse server response: ${a}` }, o = 500;
  }
  return [r, o];
}
async function Bt(e, t = {}) {
  let s = !1, n = !1;
  if (!this.config)
    throw new Error("Could not resolve app config");
  if (typeof e == "number")
    this.config.dependencies.find((i) => i.id == e);
  else {
    const i = e.replace(/^\//, "");
    this.config.dependencies.find(
      (r) => r.id == this.api_map[i]
    );
  }
  return new Promise(async (i, r) => {
    const o = this.submit(e, t, null, null, !0);
    let a;
    for await (const l of o)
      l.type === "data" && (n && i(a), s = !0, a = l), l.type === "status" && (l.stage === "error" && r(l), l.stage === "complete" && (n = !0, s && i(a)));
  });
}
async function Y(e, t, s) {
  let n = t === "subdomain" ? `https://huggingface.co/api/spaces/by-subdomain/${e}` : `https://huggingface.co/api/spaces/${e}`, i, r;
  try {
    if (i = await fetch(n), r = i.status, r !== 200)
      throw new Error();
    i = await i.json();
  } catch {
    s({
      status: "error",
      load_status: "error",
      message: dt,
      detail: "NOT_FOUND"
    });
    return;
  }
  if (!i || r !== 200)
    return;
  const {
    runtime: { stage: o },
    id: a
  } = i;
  switch (o) {
    case "STOPPED":
    case "SLEEPING":
      s({
        status: "sleeping",
        load_status: "pending",
        message: "Space is asleep. Waking it up...",
        detail: o
      }), setTimeout(() => {
        Y(e, t, s);
      }, 1e3);
      break;
    case "PAUSED":
      s({
        status: "paused",
        load_status: "error",
        message: "This space has been paused by the author. If you would like to try this demo, consider duplicating the space.",
        detail: o,
        discussions_enabled: await Ce(a)
      });
      break;
    case "RUNNING":
    case "RUNNING_BUILDING":
      s({
        status: "running",
        load_status: "complete",
        message: "Space is running.",
        detail: o
      });
      break;
    case "BUILDING":
      s({
        status: "building",
        load_status: "pending",
        message: "Space is building...",
        detail: o
      }), setTimeout(() => {
        Y(e, t, s);
      }, 1e3);
      break;
    case "APP_STARTING":
      s({
        status: "starting",
        load_status: "pending",
        message: "Space is starting...",
        detail: o
      }), setTimeout(() => {
        Y(e, t, s);
      }, 1e3);
      break;
    default:
      s({
        status: "space_error",
        load_status: "error",
        message: "This space is experiencing an issue.",
        detail: o,
        discussions_enabled: await Ce(a)
      });
      break;
  }
}
const Me = async (e, t) => {
  let s = 0;
  const n = 12, i = 5e3;
  return new Promise((r) => {
    Y(
      e,
      ge.test(e) ? "space_name" : "subdomain",
      (o) => {
        t(o), o.status === "running" || o.status === "error" || o.status === "paused" || o.status === "space_error" ? r() : (o.status === "sleeping" || o.status === "building") && (s < n ? (s++, setTimeout(() => {
          Me(e, t).then(r);
        }, i)) : r());
      }
    );
  });
}, Ft = /^(?=[^]*\b[dD]iscussions{0,1}\b)(?=[^]*\b[dD]isabled\b)[^]*$/;
async function Ce(e) {
  try {
    const t = await fetch(
      `https://huggingface.co/api/spaces/${e}/discussions`,
      {
        method: "HEAD"
      }
    ), s = t.headers.get("x-error-message");
    return !(!t.ok || s && Ft.test(s));
  } catch {
    return !1;
  }
}
async function Gt(e, t) {
  const s = {};
  t && (s.Authorization = `Bearer ${t}`);
  try {
    const n = await fetch(
      `https://huggingface.co/api/spaces/${e}/${rt}`,
      { headers: s }
    );
    if (n.status !== 200)
      throw new Error("Space hardware could not be obtained.");
    const { hardware: i } = await n.json();
    return i.current;
  } catch (n) {
    throw new Error(n.message);
  }
}
async function Mt(e, t, s) {
  const n = {};
  s && (n.Authorization = `Bearer ${s}`);
  const i = {
    seconds: t
  };
  try {
    const r = await fetch(
      `https://huggingface.co/api/spaces/${e}/${at}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json", ...n },
        body: JSON.stringify(i)
      }
    );
    if (r.status !== 200)
      throw new Error(
        "Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges."
      );
    return await r.json();
  } catch (r) {
    throw new Error(r.message);
  }
}
const Ae = [
  "cpu-basic",
  "cpu-upgrade",
  "cpu-xl",
  "t4-small",
  "t4-medium",
  "a10g-small",
  "a10g-large",
  "a10g-largex2",
  "a10g-largex4",
  "a100-large",
  "zero-a10g",
  "h100",
  "h100x8"
];
async function Jt(e, t) {
  const { hf_token: s, private: n, hardware: i, timeout: r, auth: o } = t;
  if (i && !Ae.includes(i))
    throw new Error(
      `Invalid hardware type provided. Valid types are: ${Ae.map((_) => `"${_}"`).join(",")}.`
    );
  const { http_protocol: a, host: l } = await te(
    e,
    s
  );
  let h = null;
  if (o) {
    const _ = await qe(
      a,
      l,
      o,
      fetch
    );
    _ && (h = ze(_));
  }
  const m = {
    Authorization: `Bearer ${s}`,
    "Content-Type": "application/json",
    ...h ? { Cookie: h.join("; ") } : {}
  }, p = (await (await fetch("https://huggingface.co/api/whoami-v2", {
    headers: m
  })).json()).name, g = e.split("/")[1], E = {
    repository: `${p}/${g}`
  };
  n && (E.private = !0);
  let B;
  try {
    i || (B = await Gt(e, s));
  } catch (_) {
    throw Error(me + _.message);
  }
  const c = i || B || "cpu-basic";
  E.hardware = c;
  try {
    const _ = await fetch(
      `https://huggingface.co/api/spaces/${e}/duplicate`,
      {
        method: "POST",
        headers: m,
        body: JSON.stringify(E)
      }
    );
    if (_.status === 409)
      try {
        return await ee.connect(`${p}/${g}`, t);
      } catch (C) {
        throw console.error("Failed to connect Client instance:", C), C;
      }
    else if (_.status !== 200)
      throw new Error(_.statusText);
    const N = await _.json();
    return await Mt(`${p}/${g}`, r || 300, s), await ee.connect(
      Wt(N.url),
      t
    );
  } catch (_) {
    throw new Error(_);
  }
}
function Wt(e) {
  const t = /https:\/\/huggingface.co\/spaces\/([^/]+\/[^/]+)/, s = e.match(t);
  if (s)
    return s[1];
}
var I;
class Ht extends TransformStream {
  /** Constructs a new instance. */
  constructor(s = { allowCR: !1 }) {
    super({
      transform: (n, i) => {
        for (n = V(this, I) + n; ; ) {
          const r = n.indexOf(`
`), o = s.allowCR ? n.indexOf("\r") : -1;
          if (o !== -1 && o !== n.length - 1 && (r === -1 || r - 1 > o)) {
            i.enqueue(n.slice(0, o)), n = n.slice(o + 1);
            continue;
          }
          if (r === -1)
            break;
          const a = n[r - 1] === "\r" ? r - 1 : r;
          i.enqueue(n.slice(0, a)), n = n.slice(r + 1);
        }
        Re(this, I, n);
      },
      flush: (n) => {
        if (V(this, I) === "")
          return;
        const i = s.allowCR && V(this, I).endsWith("\r") ? V(this, I).slice(0, -1) : V(this, I);
        n.enqueue(i);
      }
    });
    ke(this, I, "");
  }
}
I = new WeakMap();
function Vt(e) {
  let t = new TextDecoderStream(), s = new Ht({ allowCR: !0 });
  return e.pipeThrough(t).pipeThrough(s);
}
function Zt(e) {
  let s = /[:]\s*/.exec(e), n = s && s.index;
  if (n)
    return [
      e.substring(0, n),
      e.substring(n + s[0].length)
    ];
}
function Le(e, t, s) {
  e.get(t) || e.set(t, s);
}
async function* Kt(e, t) {
  if (!e.body)
    return;
  let s = Vt(e.body), n, i = s.getReader(), r;
  for (; ; ) {
    if (t && t.aborted)
      return i.cancel();
    if (n = await i.read(), n.done)
      return;
    if (!n.value) {
      r && (yield r), r = void 0;
      continue;
    }
    let [o, a] = Zt(n.value) || [];
    o && (o === "data" ? (r || (r = {}), r[o] = r[o] ? r[o] + `
` + a : a) : o === "event" ? (r || (r = {}), r[o] = a) : o === "id" ? (r || (r = {}), r[o] = +a || a) : o === "retry" && (r || (r = {}), r[o] = +a || void 0));
  }
}
async function Qt(e, t) {
  let s = new Request(e, t);
  Le(s.headers, "Accept", "text/event-stream"), Le(s.headers, "Content-Type", "application/json");
  let n = await fetch(s);
  if (!n.ok)
    throw n;
  return Kt(n, s.signal);
}
async function Xt() {
  let {
    event_callbacks: e,
    unclosed_events: t,
    pending_stream_messages: s,
    stream_status: n,
    config: i,
    jwt: r
  } = this;
  const o = this;
  if (!i)
    throw new Error("Could not resolve app config");
  n.open = !0;
  let a = null, l = new URLSearchParams({
    session_hash: this.session_hash
  }).toString(), h = new URL(`${i.root}${this.api_prefix}/${je}?${l}`);
  if (r && h.searchParams.set("__sign", r), a = this.stream(h), !a) {
    console.warn("Cannot connect to SSE endpoint: " + h.toString());
    return;
  }
  a.onmessage = async function(m) {
    let p = JSON.parse(m.data);
    if (p.msg === "close_stream") {
      we(n, o.abort_controller);
      return;
    }
    const g = p.event_id;
    if (!g)
      await Promise.all(
        Object.keys(e).map(
          (E) => e[E](p)
        )
      );
    else if (e[g] && i) {
      p.msg === "process_completed" && ["sse", "sse_v1", "sse_v2", "sse_v2.1", "sse_v3"].includes(
        i.protocol
      ) && t.delete(g);
      let E = e[g];
      typeof window < "u" && typeof document < "u" ? setTimeout(E, 0, p) : E(p);
    } else
      s[g] || (s[g] = []), s[g].push(p);
  }, a.onerror = async function(m) {
    console.error(m), await Promise.all(
      Object.keys(e).map(
        (p) => e[p]({
          msg: "broken_connection",
          message: J
        })
      )
    );
  };
}
function we(e, t) {
  e && (e.open = !1, t == null || t.abort());
}
function Yt(e, t, s) {
  !e[t] ? (e[t] = [], s.data.forEach((i, r) => {
    e[t][r] = i;
  })) : s.data.forEach((i, r) => {
    let o = es(e[t][r], i);
    e[t][r] = o, s.data[r] = o;
  });
}
function es(e, t) {
  return t.forEach(([s, n, i]) => {
    e = ts(e, n, s, i);
  }), e;
}
function ts(e, t, s, n) {
  if (t.length === 0) {
    if (s === "replace")
      return n;
    if (s === "append")
      return e + n;
    throw new Error(`Unsupported action: ${s}`);
  }
  let i = e;
  for (let o = 0; o < t.length - 1; o++)
    i = i[t[o]];
  const r = t[t.length - 1];
  switch (s) {
    case "replace":
      i[r] = n;
      break;
    case "append":
      i[r] += n;
      break;
    case "add":
      Array.isArray(i) ? i.splice(Number(r), 0, n) : i[r] = n;
      break;
    case "delete":
      Array.isArray(i) ? i.splice(Number(r), 1) : delete i[r];
      break;
    default:
      throw new Error(`Unknown action: ${s}`);
  }
  return e;
}
function ss(e, t = {}) {
  const s = {
    close: () => {
      console.warn("Method not implemented.");
    },
    onerror: null,
    onmessage: null,
    onopen: null,
    readyState: 0,
    url: e.toString(),
    withCredentials: !1,
    CONNECTING: 0,
    OPEN: 1,
    CLOSED: 2,
    addEventListener: () => {
      throw new Error("Method not implemented.");
    },
    dispatchEvent: () => {
      throw new Error("Method not implemented.");
    },
    removeEventListener: () => {
      throw new Error("Method not implemented.");
    }
  };
  return Qt(e, t).then(async (n) => {
    s.readyState = s.OPEN;
    try {
      for await (const i of n)
        s.onmessage && s.onmessage(i);
      s.readyState = s.CLOSED;
    } catch (i) {
      s.onerror && s.onerror(i), s.readyState = s.CLOSED;
    }
  }).catch((n) => {
    console.error(n), s.onerror && s.onerror(n), s.readyState = s.CLOSED;
  }), s;
}
function ns(e, t = {}, s, n, i) {
  var r;
  try {
    let o = function(w) {
      (i || Ze[w.type]) && m(w);
    }, a = function() {
      for (le = !0; K.length > 0; )
        K.shift()({
          value: void 0,
          done: !0
        });
    }, l = function(w) {
      le || (K.length > 0 ? K.shift()(w) : ue.push(w));
    }, h = function(w) {
      l(is(w)), a();
    }, m = function(w) {
      l({ value: w, done: !1 });
    }, p = function() {
      return ue.length > 0 ? Promise.resolve(ue.shift()) : le ? Promise.resolve({ value: void 0, done: !0 }) : new Promise((w) => K.push(w));
    };
    const { hf_token: g } = this.options, {
      fetch: E,
      app_reference: B,
      config: c,
      session_hash: _,
      api_info: N,
      api_map: C,
      stream_status: ne,
      pending_stream_messages: ie,
      pending_diff_streams: oe,
      event_callbacks: re,
      unclosed_events: Je,
      post_data: ae,
      options: F,
      api_prefix: W
    } = this, We = this;
    if (!N)
      throw new Error("No API found");
    if (!c)
      throw new Error("Could not resolve app config");
    let { fn_index: f, endpoint_info: ye, dependency: H } = os(
      N,
      e,
      C,
      c
    ), He = Dt(t, ye), R, T, j = c.protocol ?? "ws", be = "", Ve = () => be;
    const d = typeof e == "number" ? "/predict" : e;
    let Z, S = null, O = !1, ce = {}, G = typeof window < "u" && typeof document < "u" ? new URLSearchParams(window.location.search).toString() : "";
    const Ze = ((r = F == null ? void 0 : F.events) == null ? void 0 : r.reduce(
      (w, x) => (w[x] = !0, w),
      {}
    )) || {};
    async function Ke() {
      const w = {
        stage: "complete",
        queue: !1,
        time: /* @__PURE__ */ new Date()
      };
      O = w, o({
        ...w,
        type: "status",
        endpoint: d,
        fn_index: f
      });
      let x = {}, M = {};
      j === "ws" ? (R && R.readyState === 0 ? R.addEventListener("open", () => {
        R.close();
      }) : R.close(), x = { fn_index: f, session_hash: _ }) : (x = { event_id: S }, M = { event_id: S, session_hash: _, fn_index: f });
      try {
        if (!c)
          throw new Error("Could not resolve app config");
        "event_id" in M && await E(`${c.root}${W}/${pt}`, {
          headers: { "Content-Type": "application/json" },
          method: "POST",
          body: JSON.stringify(M)
        }), await E(`${c.root}${W}/${ut}`, {
          headers: { "Content-Type": "application/json" },
          method: "POST",
          body: JSON.stringify(x)
        });
      } catch {
        console.warn(
          "The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable."
        );
      }
    }
    const Qe = async (w) => {
      await this._resolve_heartbeat(w);
    };
    async function ve(w) {
      if (!c)
        return;
      let x = w.render_id;
      c.components = [
        ...c.components.filter((y) => y.props.rendered_in !== x),
        ...w.components
      ], c.dependencies = [
        ...c.dependencies.filter((y) => y.rendered_in !== x),
        ...w.dependencies
      ];
      const M = c.components.some((y) => y.type === "state"), Q = c.dependencies.some(
        (y) => y.targets.some((U) => U[1] === "unload")
      );
      c.connect_heartbeat = M || Q, await Qe(c), o({
        type: "render",
        data: w,
        endpoint: d,
        fn_index: f
      });
    }
    this.handle_blob(c.root, He, ye).then(
      async (w) => {
        var Q;
        if (Z = {
          data: X(
            w,
            H,
            c.components,
            "input",
            !0
          ) || [],
          event_data: s,
          fn_index: f,
          trigger_id: n
        }, jt(f, c))
          o({
            type: "status",
            endpoint: d,
            stage: "pending",
            queue: !1,
            fn_index: f,
            time: /* @__PURE__ */ new Date()
          }), ae(
            `${c.root}${W}/run${d.startsWith("/") ? d : `/${d}`}${G ? "?" + G : ""}`,
            {
              ...Z,
              session_hash: _
            }
          ).then(([y, U]) => {
            const q = y.data;
            U == 200 ? (o({
              type: "data",
              endpoint: d,
              fn_index: f,
              data: X(
                q,
                H,
                c.components,
                "output",
                F.with_null_state
              ),
              time: /* @__PURE__ */ new Date(),
              event_data: s,
              trigger_id: n
            }), y.render_config && ve(y.render_config), o({
              type: "status",
              endpoint: d,
              fn_index: f,
              stage: "complete",
              eta: y.average_duration,
              queue: !1,
              time: /* @__PURE__ */ new Date()
            })) : o({
              type: "status",
              stage: "error",
              endpoint: d,
              fn_index: f,
              message: y.error,
              queue: !1,
              time: /* @__PURE__ */ new Date()
            });
          }).catch((y) => {
            o({
              type: "status",
              stage: "error",
              message: y.message,
              endpoint: d,
              fn_index: f,
              queue: !1,
              time: /* @__PURE__ */ new Date()
            });
          });
        else if (j == "ws") {
          const { ws_protocol: y, host: U } = await te(
            B,
            g
          );
          o({
            type: "status",
            stage: "pending",
            queue: !0,
            endpoint: d,
            fn_index: f,
            time: /* @__PURE__ */ new Date()
          });
          let q = new URL(
            `${y}://${vt(
              U,
              c.root,
              !0
            )}/queue/join${G ? "?" + G : ""}`
          );
          this.jwt && q.searchParams.set("__sign", this.jwt), R = new WebSocket(q), R.onclose = (A) => {
            A.wasClean || o({
              type: "status",
              stage: "error",
              broken: !0,
              message: J,
              queue: !0,
              endpoint: d,
              fn_index: f,
              time: /* @__PURE__ */ new Date()
            });
          }, R.onmessage = function(A) {
            const k = JSON.parse(A.data), { type: $, status: v, data: D } = de(
              k,
              ce[f]
            );
            if ($ === "update" && v && !O)
              o({
                type: "status",
                endpoint: d,
                fn_index: f,
                time: /* @__PURE__ */ new Date(),
                ...v
              }), v.stage === "error" && R.close();
            else if ($ === "hash") {
              R.send(JSON.stringify({ fn_index: f, session_hash: _ }));
              return;
            } else
              $ === "data" ? R.send(JSON.stringify({ ...Z, session_hash: _ })) : $ === "complete" ? O = v : $ === "log" ? o({
                type: "log",
                title: D.title,
                log: D.log,
                level: D.level,
                endpoint: d,
                duration: D.duration,
                visible: D.visible,
                fn_index: f
              }) : $ === "generating" && o({
                type: "status",
                time: /* @__PURE__ */ new Date(),
                ...v,
                stage: v == null ? void 0 : v.stage,
                queue: !0,
                endpoint: d,
                fn_index: f
              });
            D && (o({
              type: "data",
              time: /* @__PURE__ */ new Date(),
              data: X(
                D.data,
                H,
                c.components,
                "output",
                F.with_null_state
              ),
              endpoint: d,
              fn_index: f,
              event_data: s,
              trigger_id: n
            }), O && (o({
              type: "status",
              time: /* @__PURE__ */ new Date(),
              ...O,
              stage: v == null ? void 0 : v.stage,
              queue: !0,
              endpoint: d,
              fn_index: f
            }), R.close()));
          }, Pe(c.version || "2.0.0", "3.6") < 0 && addEventListener(
            "open",
            () => R.send(JSON.stringify({ hash: _ }))
          );
        } else if (j == "sse") {
          o({
            type: "status",
            stage: "pending",
            queue: !0,
            endpoint: d,
            fn_index: f,
            time: /* @__PURE__ */ new Date()
          });
          var M = new URLSearchParams({
            fn_index: f.toString(),
            session_hash: _
          }).toString();
          let y = new URL(
            `${c.root}${W}/${je}?${G ? G + "&" : ""}${M}`
          );
          if (this.jwt && y.searchParams.set("__sign", this.jwt), T = this.stream(y), !T)
            return Promise.reject(
              new Error("Cannot connect to SSE endpoint: " + y.toString())
            );
          T.onmessage = async function(U) {
            const q = JSON.parse(U.data), { type: A, status: k, data: $ } = de(
              q,
              ce[f]
            );
            if (A === "update" && k && !O)
              o({
                type: "status",
                endpoint: d,
                fn_index: f,
                time: /* @__PURE__ */ new Date(),
                ...k
              }), k.stage === "error" && (T == null || T.close(), a());
            else if (A === "data") {
              let [v, D] = await ae(
                `${c.root}${W}/queue/data`,
                {
                  ...Z,
                  session_hash: _,
                  event_id: S
                }
              );
              D !== 200 && (o({
                type: "status",
                stage: "error",
                message: J,
                queue: !0,
                endpoint: d,
                fn_index: f,
                time: /* @__PURE__ */ new Date()
              }), T == null || T.close(), a());
            } else
              A === "complete" ? O = k : A === "log" ? o({
                type: "log",
                title: $.title,
                log: $.log,
                level: $.level,
                endpoint: d,
                duration: $.duration,
                visible: $.visible,
                fn_index: f
              }) : (A === "generating" || A === "streaming") && o({
                type: "status",
                time: /* @__PURE__ */ new Date(),
                ...k,
                stage: k == null ? void 0 : k.stage,
                queue: !0,
                endpoint: d,
                fn_index: f
              });
            $ && (o({
              type: "data",
              time: /* @__PURE__ */ new Date(),
              data: X(
                $.data,
                H,
                c.components,
                "output",
                F.with_null_state
              ),
              endpoint: d,
              fn_index: f,
              event_data: s,
              trigger_id: n
            }), O && (o({
              type: "status",
              time: /* @__PURE__ */ new Date(),
              ...O,
              stage: k == null ? void 0 : k.stage,
              queue: !0,
              endpoint: d,
              fn_index: f
            }), T == null || T.close(), a()));
          };
        } else if (j == "sse_v1" || j == "sse_v2" || j == "sse_v2.1" || j == "sse_v3") {
          o({
            type: "status",
            stage: "pending",
            queue: !0,
            endpoint: d,
            fn_index: f,
            time: /* @__PURE__ */ new Date()
          });
          let y = "";
          typeof window < "u" && typeof document < "u" && (y = (Q = window == null ? void 0 : window.location) == null ? void 0 : Q.hostname);
          const q = y.includes(".dev.") ? `https://moon-${y.split(".")[1]}.dev.spaces.huggingface.tech` : "https://huggingface.co";
          (typeof window < "u" && typeof document < "u" && window.parent != window && window.supports_zerogpu_headers ? xt("zerogpu-headers", q) : Promise.resolve(null)).then((v) => ae(
            `${c.root}${W}/${nt}?${G}`,
            {
              ...Z,
              session_hash: _
            },
            v
          )).then(async ([v, D]) => {
            if (D === 503)
              o({
                type: "status",
                stage: "error",
                message: xe,
                queue: !0,
                endpoint: d,
                fn_index: f,
                time: /* @__PURE__ */ new Date()
              });
            else if (D !== 200)
              o({
                type: "status",
                stage: "error",
                broken: !0,
                message: J,
                queue: !0,
                endpoint: d,
                fn_index: f,
                time: /* @__PURE__ */ new Date()
              });
            else {
              S = v.event_id, be = S;
              let Se = async function(pe) {
                try {
                  const { type: L, status: b, data: P, original_msg: Xe } = de(
                    pe,
                    ce[f]
                  );
                  if (L == "heartbeat")
                    return;
                  if (L === "update" && b && !O)
                    o({
                      type: "status",
                      endpoint: d,
                      fn_index: f,
                      time: /* @__PURE__ */ new Date(),
                      original_msg: Xe,
                      ...b
                    });
                  else if (L === "complete")
                    O = b;
                  else if (L == "unexpected_error" || L == "broken_connection") {
                    console.error("Unexpected error", b == null ? void 0 : b.message);
                    const Ye = L === "broken_connection";
                    o({
                      type: "status",
                      stage: "error",
                      message: (b == null ? void 0 : b.message) || "An Unexpected Error Occurred!",
                      queue: !0,
                      endpoint: d,
                      broken: Ye,
                      session_not_found: b == null ? void 0 : b.session_not_found,
                      fn_index: f,
                      time: /* @__PURE__ */ new Date()
                    });
                  } else if (L === "log") {
                    o({
                      type: "log",
                      title: P.title,
                      log: P.log,
                      level: P.level,
                      endpoint: d,
                      duration: P.duration,
                      visible: P.visible,
                      fn_index: f
                    });
                    return;
                  } else
                    (L === "generating" || L === "streaming") && (o({
                      type: "status",
                      time: /* @__PURE__ */ new Date(),
                      ...b,
                      stage: b == null ? void 0 : b.stage,
                      queue: !0,
                      endpoint: d,
                      fn_index: f
                    }), P && H.connection !== "stream" && ["sse_v2", "sse_v2.1", "sse_v3"].includes(j) && Yt(oe, S, P));
                  P && (o({
                    type: "data",
                    time: /* @__PURE__ */ new Date(),
                    data: X(
                      P.data,
                      H,
                      c.components,
                      "output",
                      F.with_null_state
                    ),
                    endpoint: d,
                    fn_index: f
                  }), P.render_config && await ve(P.render_config), O && (o({
                    type: "status",
                    time: /* @__PURE__ */ new Date(),
                    ...O,
                    stage: b == null ? void 0 : b.stage,
                    queue: !0,
                    endpoint: d,
                    fn_index: f
                  }), a())), ((b == null ? void 0 : b.stage) === "complete" || (b == null ? void 0 : b.stage) === "error") && (re[S] && delete re[S], S in oe && delete oe[S]);
                } catch (L) {
                  console.error("Unexpected client exception", L), o({
                    type: "status",
                    stage: "error",
                    message: "An Unexpected Error Occurred!",
                    queue: !0,
                    endpoint: d,
                    fn_index: f,
                    time: /* @__PURE__ */ new Date()
                  }), ["sse_v2", "sse_v2.1", "sse_v3"].includes(j) && (we(ne, We.abort_controller), ne.open = !1, a());
                }
              };
              S in ie && (ie[S].forEach(
                (pe) => Se(pe)
              ), delete ie[S]), re[S] = Se, Je.add(S), ne.open || await this.open_stream();
            }
          });
        }
      }
    );
    let le = !1;
    const ue = [], K = [], Ee = {
      [Symbol.asyncIterator]: () => Ee,
      next: p,
      throw: async (w) => (h(w), p()),
      return: async () => (a(), p()),
      cancel: Ke,
      event_id: Ve
    };
    return Ee;
  } catch (o) {
    throw console.error("Submit function encountered an error:", o), o;
  }
}
function is(e) {
  return {
    then: (t, s) => s(e)
  };
}
function os(e, t, s, n) {
  let i, r, o;
  if (typeof t == "number")
    i = t, r = e.unnamed_endpoints[i], o = n.dependencies.find((a) => a.id == t);
  else {
    const a = t.replace(/^\//, "");
    i = s[a], r = e.named_endpoints[t.trim()], o = n.dependencies.find(
      (l) => l.id == s[a]
    );
  }
  if (typeof i != "number")
    throw new Error(
      "There is no endpoint matching that name of fn_index matching that number."
    );
  return { fn_index: i, endpoint_info: r, dependency: o };
}
class ee {
  constructor(t, s = { events: ["data"] }) {
    u(this, "app_reference");
    u(this, "options");
    u(this, "deep_link", null);
    u(this, "config");
    u(this, "api_prefix", "");
    u(this, "api_info");
    u(this, "api_map", {});
    u(this, "session_hash", Math.random().toString(36).substring(2));
    u(this, "jwt", !1);
    u(this, "last_status", {});
    u(this, "cookies", null);
    // streaming
    u(this, "stream_status", { open: !1 });
    u(this, "closed", !1);
    u(this, "pending_stream_messages", {});
    u(this, "pending_diff_streams", {});
    u(this, "event_callbacks", {});
    u(this, "unclosed_events", /* @__PURE__ */ new Set());
    u(this, "heartbeat_event", null);
    u(this, "abort_controller", null);
    u(this, "stream_instance", null);
    u(this, "current_payload");
    u(this, "ws_map", {});
    u(this, "view_api");
    u(this, "upload_files");
    u(this, "upload");
    u(this, "handle_blob");
    u(this, "post_data");
    u(this, "submit");
    u(this, "predict");
    u(this, "open_stream");
    u(this, "resolve_config");
    u(this, "resolve_cookies");
    var n;
    this.app_reference = t, this.deep_link = ((n = s.query_params) == null ? void 0 : n.deep_link) || null, s.events || (s.events = ["data"]), this.options = s, this.current_payload = {}, this.view_api = Ct.bind(this), this.upload_files = At.bind(this), this.handle_blob = It.bind(this), this.post_data = zt.bind(this), this.submit = ns.bind(this), this.predict = Bt.bind(this), this.open_stream = Xt.bind(this), this.resolve_config = St.bind(this), this.resolve_cookies = kt.bind(this), this.upload = Lt.bind(this), this.fetch = this.fetch.bind(this), this.handle_space_success = this.handle_space_success.bind(this), this.stream = this.stream.bind(this);
  }
  get_url_config(t = null) {
    if (!this.config)
      throw new Error(z);
    t === null && (t = window.location.href);
    const s = (o) => o.replace(/^\/+|\/+$/g, "");
    let n = s(new URL(this.config.root).pathname), i = s(new URL(t).pathname), r;
    return i.startsWith(n) ? r = s(i.substring(n.length)) : r = "", this.get_page_config(r);
  }
  get_page_config(t) {
    if (!this.config)
      throw new Error(z);
    let s = this.config;
    return t in s.page || (t = ""), {
      ...s,
      current_page: t,
      layout: s.page[t].layout,
      components: s.components.filter(
        (n) => s.page[t].components.includes(n.id)
      ),
      dependencies: this.config.dependencies.filter(
        (n) => s.page[t].dependencies.includes(n.id)
      )
    };
  }
  fetch(t, s) {
    const n = new Headers((s == null ? void 0 : s.headers) || {});
    if (this && this.cookies && n.append("Cookie", this.cookies), this && this.options.headers)
      for (const i in this.options.headers)
        n.append(i, this.options.headers[i]);
    return fetch(t, { ...s, headers: n });
  }
  stream(t) {
    const s = new Headers();
    if (this && this.cookies && s.append("Cookie", this.cookies), this && this.options.headers)
      for (const n in this.options.headers)
        s.append(n, this.options.headers[n]);
    return this && this.options.hf_token && s.append("Authorization", `Bearer ${this.options.hf_token}`), this.abort_controller = new AbortController(), this.stream_instance = ss(t.toString(), {
      credentials: "include",
      headers: s,
      signal: this.abort_controller.signal
    }), this.stream_instance;
  }
  async init() {
    var t;
    this.options.auth && await this.resolve_cookies(), await this._resolve_config().then(
      ({ config: s }) => this._resolve_heartbeat(s)
    ), this.api_info = await this.view_api(), this.api_map = Et(((t = this.config) == null ? void 0 : t.dependencies) || []);
  }
  async _resolve_heartbeat(t) {
    if (t && (this.config = t, this.api_prefix = t.api_prefix || "", this.config && this.config.connect_heartbeat && this.config.space_id && this.options.hf_token && (this.jwt = await Te(
      this.config.space_id,
      this.options.hf_token,
      this.cookies
    ))), t.space_id && this.options.hf_token && (this.jwt = await Te(t.space_id, this.options.hf_token)), this.config && this.config.connect_heartbeat) {
      const s = new URL(
        `${this.config.root}${this.api_prefix}/${ct}/${this.session_hash}`
      );
      this.jwt && s.searchParams.set("__sign", this.jwt), this.heartbeat_event || (this.heartbeat_event = this.stream(s));
    }
  }
  static async connect(t, s = {
    events: ["data"]
  }) {
    const n = new this(t, s);
    return s.session_hash && (n.session_hash = s.session_hash), await n.init(), n;
  }
  async reconnect() {
    const t = new URL(
      `${this.config.root}${this.api_prefix}/${ft}`
    );
    let s;
    try {
      const n = await this.fetch(t);
      if (!n.ok)
        throw new Error();
      s = (await n.json()).app_id;
    } catch {
      return "broken";
    }
    return s !== this.config.app_id ? "changed" : "connected";
  }
  close() {
    this.closed = !0, we(this.stream_status, this.abort_controller);
  }
  set_current_payload(t) {
    this.current_payload = t;
  }
  static async duplicate(t, s = {
    events: ["data"]
  }) {
    return Jt(t, s);
  }
  async _resolve_config() {
    const { http_protocol: t, host: s, space_id: n } = await te(
      this.app_reference,
      this.options.hf_token
    ), { status_callback: i } = this.options;
    n && i && await Me(n, i);
    let r;
    try {
      let o = `${t}//${s}`;
      if (r = await this.resolve_config(o), !r)
        throw new Error(z);
      return this.config_success(r);
    } catch (o) {
      if (n && i)
        Y(
          n,
          ge.test(n) ? "space_name" : "subdomain",
          this.handle_space_success
        );
      else
        throw i && i({
          status: "error",
          message: "Could not load this space.",
          load_status: "error",
          detail: "NOT_FOUND"
        }), Error(o);
    }
  }
  async config_success(t) {
    if (this.config = t, this.api_prefix = t.api_prefix || "", this.config.auth_required)
      return this.prepare_return_obj();
    try {
      this.api_info = await this.view_api();
    } catch (s) {
      console.error(_t + s.message);
    }
    return this.prepare_return_obj();
  }
  async handle_space_success(t) {
    var n;
    if (!this)
      throw new Error(z);
    const { status_callback: s } = this.options;
    if (s && s(t), t.status === "running")
      try {
        if (this.config = await this._resolve_config(), this.api_prefix = ((n = this == null ? void 0 : this.config) == null ? void 0 : n.api_prefix) || "", !this.config)
          throw new Error(z);
        return await this.config_success(this.config);
      } catch (i) {
        throw s && s({
          status: "error",
          message: "Could not load this space.",
          load_status: "error",
          detail: "NOT_FOUND"
        }), i;
      }
  }
  async component_server(t, s, n) {
    var m;
    if (!this.config)
      throw new Error(z);
    const i = {}, { hf_token: r } = this.options, { session_hash: o } = this;
    r && (i.Authorization = `Bearer ${this.options.hf_token}`);
    let a, l = this.config.components.find(
      (p) => p.id === t
    );
    (m = l == null ? void 0 : l.props) != null && m.root_url ? a = l.props.root_url : a = this.config.root;
    let h;
    if ("binary" in n) {
      h = new FormData();
      for (const p in n.data)
        p !== "binary" && h.append(p, n.data[p]);
      h.set("component_id", t.toString()), h.set("fn_name", s), h.set("session_hash", o);
    } else
      h = JSON.stringify({
        data: n,
        component_id: t,
        fn_name: s,
        session_hash: o
      }), i["Content-Type"] = "application/json";
    r && (i.Authorization = `Bearer ${r}`);
    try {
      const p = await this.fetch(
        `${a}${this.api_prefix}/${lt}/`,
        {
          method: "POST",
          body: h,
          headers: i,
          credentials: "include"
        }
      );
      if (!p.ok)
        throw new Error(
          "Could not connect to component server: " + p.statusText
        );
      return await p.json();
    } catch (p) {
      console.warn(p);
    }
  }
  set_cookies(t) {
    this.cookies = ze(t).join("; ");
  }
  prepare_return_obj() {
    return {
      config: this.config,
      predict: this.predict,
      submit: this.submit,
      view_api: this.view_api,
      component_server: this.component_server
    };
  }
  async connect_ws(t) {
    return new Promise((s, n) => {
      let i;
      try {
        i = new WebSocket(t);
      } catch {
        this.ws_map[t] = "failed";
        return;
      }
      this.ws_map[t] = "pending", i.onopen = () => {
        this.ws_map[t] = i, s();
      }, i.onerror = (r) => {
        console.error("WebSocket error:", r), this.close_ws(t), this.ws_map[t] = "failed", s();
      }, i.onclose = () => {
        this.ws_map[t] = "closed";
      }, i.onmessage = (r) => {
      };
    });
  }
  async send_ws_message(t, s) {
    if (!(t in this.ws_map))
      await this.connect_ws(t);
    else if (this.ws_map[t] === "pending" || this.ws_map[t] === "closed" || this.ws_map[t] === "failed")
      return;
    const n = this.ws_map[t];
    n instanceof WebSocket ? n.send(JSON.stringify(s)) : this.post_data(t, s);
  }
  async close_ws(t) {
    if (t in this.ws_map) {
      const s = this.ws_map[t];
      s instanceof WebSocket && (s.close(), delete this.ws_map[t]);
    }
  }
}
async function ls(e, t = {
  events: ["data"]
}) {
  return await ee.connect(e, t);
}
async function us(e, t) {
  return await ee.duplicate(e, t);
}
export {
  ee as Client,
  se as FileData,
  wt as MISSING_CREDENTIALS_MSG,
  ls as client,
  us as duplicate,
  cs as handle_file,
  Bt as predict,
  as as prepare_files,
  ns as submit,
  Lt as upload,
  At as upload_files
};
